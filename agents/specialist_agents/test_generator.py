"""
Test Generator Agent for AI Code Orchestrator v3.0

Generates unit tests, integration tests, and test suites for code
produced by other agents. Uses LLM to understand code and create
comprehensive test coverage.
"""

from __future__ import annotations

import logging
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from enum import Enum

logger = logging.getLogger(__name__)


class TestType(Enum):
    UNIT = "unit"
    INTEGRATION = "integration"
    E2E = "e2e"
    PROPERTY = "property"


class TestFramework(Enum):
    PYTEST = "pytest"
    JEST = "jest"
    XUNIT = "xunit"
    NUNIT = "nunit"


@dataclass
class TestCase:
    """Represents a single test case."""
    name: str
    description: str
    test_type: TestType
    code: str
    setup: str = ""
    teardown: str = ""
    expected_result: Optional[str] = None
    tags: List[str] = field(default_factory=list)


@dataclass
class TestSuite:
    """Collection of test cases for a module/component."""
    name: str
    target_file: str
    framework: TestFramework
    test_cases: List[TestCase] = field(default_factory=list)
    imports: List[str] = field(default_factory=list)
    fixtures: List[str] = field(default_factory=list)
    
    def to_code(self) -> str:
        """Generate complete test file code."""
        if self.framework == TestFramework.PYTEST:
            return self._to_pytest()
        elif self.framework == TestFramework.JEST:
            return self._to_jest()
        elif self.framework == TestFramework.XUNIT:
            return self._to_xunit()
        else:
            raise ValueError(f"Unsupported framework: {self.framework}")
    
    def _to_pytest(self) -> str:
        """Generate pytest test file."""
        lines = [
            '"""',
            f'Tests for {self.target_file}',
            'Auto-generated by TestGeneratorAgent',
            '"""',
            '',
            'import pytest',
        ]
        
        # Add imports
        for imp in self.imports:
            lines.append(imp)
        
        lines.append('')
        
        # Add fixtures
        for fixture in self.fixtures:
            lines.append(fixture)
            lines.append('')
        
        # Add test cases
        for test in self.test_cases:
            lines.append(f'def test_{test.name}():')
            lines.append(f'    """{test.description}"""')
            if test.setup:
                lines.append(f'    # Setup')
                for line in test.setup.split('\n'):
                    lines.append(f'    {line}')
            lines.append(f'    # Test')
            for line in test.code.split('\n'):
                lines.append(f'    {line}')
            lines.append('')
        
        return '\n'.join(lines)
    
    def _to_jest(self) -> str:
        """Generate Jest test file."""
        lines = [
            '/**',
            f' * Tests for {self.target_file}',
            ' * Auto-generated by TestGeneratorAgent',
            ' */',
            '',
        ]
        
        # Add imports
        for imp in self.imports:
            lines.append(imp)
        
        lines.append('')
        lines.append(f"describe('{self.name}', () => {{")
        
        # Add test cases
        for test in self.test_cases:
            lines.append(f"  test('{test.description}', () => {{")
            for line in test.code.split('\n'):
                lines.append(f'    {line}')
            lines.append('  });')
            lines.append('')
        
        lines.append('});')
        
        return '\n'.join(lines)
    
    def _to_xunit(self) -> str:
        """Generate xUnit test file."""
        lines = [
            'using Xunit;',
            'using System;',
        ]
        
        # Add imports
        for imp in self.imports:
            lines.append(imp)
        
        lines.extend([
            '',
            f'namespace {self.name.replace(" ", "")}Tests',
            '{',
            f'    /// <summary>',
            f'    /// Tests for {self.target_file}',
            f'    /// Auto-generated by TestGeneratorAgent',
            f'    /// </summary>',
            f'    public class {self.name.replace(" ", "")}Tests',
            '    {'
        ])
        
        # Add test cases
        for test in self.test_cases:
            lines.append('        [Fact]')
            lines.append(f'        public void {test.name}()')
            lines.append('        {')
            lines.append(f'            // {test.description}')
            for line in test.code.split('\n'):
                lines.append(f'            {line}')
            lines.append('        }')
            lines.append('')
        
        lines.append('    }')
        lines.append('}')
        
        return '\n'.join(lines)


class TestGeneratorAgent:
    """
    Agent responsible for generating tests for code.
    
    Uses LLM to analyze code and generate comprehensive test suites
    covering happy paths, edge cases, and error scenarios.
    """
    
    def __init__(self, llm_client=None):
        """
        Initialize TestGeneratorAgent.
        
        Args:
            llm_client: LLM client for generating tests (optional for templates)
        """
        self.llm_client = llm_client
        
    def detect_language(self, code: str) -> str:
        """Detect programming language from code."""
        if 'def ' in code and ':' in code:
            return 'python'
        elif 'function ' in code or 'const ' in code or '=>' in code:
            return 'typescript'
        elif 'public class' in code or 'namespace ' in code:
            return 'csharp'
        else:
            return 'unknown'
    
    def get_framework(self, language: str) -> TestFramework:
        """Get appropriate test framework for language."""
        frameworks = {
            'python': TestFramework.PYTEST,
            'typescript': TestFramework.JEST,
            'javascript': TestFramework.JEST,
            'csharp': TestFramework.XUNIT,
        }
        return frameworks.get(language, TestFramework.PYTEST)
    
    async def generate_unit_tests(
        self,
        code: str,
        context: Dict[str, Any] = None
    ) -> TestSuite:
        """
        Generate unit tests for given code.
        
        Args:
            code: Source code to test
            context: Additional context (function signatures, types, etc.)
            
        Returns:
            TestSuite with generated test cases
        """
        language = self.detect_language(code)
        framework = self.get_framework(language)
        
        if self.llm_client:
            # Use LLM to generate tests
            return await self._generate_with_llm(code, language, framework, context)
        else:
            # Use template-based generation
            return self._generate_from_template(code, language, framework)
    
    async def generate_integration_tests(
        self,
        plan: Dict[str, Any],
        files: Dict[str, str]
    ) -> List[TestSuite]:
        """
        Generate integration tests based on implementation plan.
        
        Args:
            plan: Implementation plan with component interactions
            files: Dictionary of filename -> code
            
        Returns:
            List of TestSuite for integration testing
        """
        test_suites = []
        
        # Analyze plan for integration points
        if 'milestones' in plan:
            for milestone in plan['milestones']:
                if 'integration_points' in milestone:
                    suite = await self._generate_integration_suite(
                        milestone,
                        files
                    )
                    test_suites.append(suite)
        
        return test_suites
    
    async def _generate_with_llm(
        self,
        code: str,
        language: str,
        framework: TestFramework,
        context: Dict[str, Any] = None
    ) -> TestSuite:
        """Generate tests using LLM."""
        prompt = self._build_test_generation_prompt(
            code, language, framework, context
        )
        
        # Call LLM
        try:
            response = await self.llm_client.complete(
                messages=[
                    {"role": "system", "content": "You are an expert software tester. Output only code."},
                    {"role": "user", "content": prompt}
                ],
                model="gpt-4", # Placeholder model name, mock client ignores it
                temperature=0.0
            )
            
            # Parse response content
            content = response.content
            if "```" in content:
                # Extract code block
                import re
                blocks = re.findall(r'```(?:\w+)?\n(.*?)```', content, re.DOTALL)
                if blocks:
                    content = blocks[0].strip()
                else:
                    content = content.replace("```", "").strip()
            
            # Parse parsed content into TestSuite (simplified for now)
            # In a real implementation, we'd parse this more robustly or ask for JSON
            # For simulation, we'll extract the code and wrap it
            
            return TestSuite(
                name="GeneratedTests",
                target_file="main",
                framework=framework,
                test_cases=[TestCase(
                    name="llm_generated_test",
                    description="Test generated by LLM",
                    test_type=TestType.UNIT,
                    code=content
                )],
                imports=self._get_default_imports(language)
            )

        except Exception as e:
            logger.warning(f"LLM test generation failed: {e}")
            return self._generate_from_template(code, language, framework)
    
    def _generate_from_template(
        self,
        code: str,
        language: str,
        framework: TestFramework
    ) -> TestSuite:
        """Generate basic tests from templates."""
        test_cases = []
        
        # Extract function/method names
        functions = self._extract_functions(code, language)
        
        for func_name in functions:
            # Generate basic test case
            test_cases.append(TestCase(
                name=f"{func_name}_basic",
                description=f"Test basic functionality of {func_name}",
                test_type=TestType.UNIT,
                code=self._generate_basic_test(func_name, language)
            ))
            
            # Generate edge case test
            test_cases.append(TestCase(
                name=f"{func_name}_edge_cases",
                description=f"Test edge cases for {func_name}",
                test_type=TestType.UNIT,
                code=self._generate_edge_case_test(func_name, language)
            ))
        
        return TestSuite(
            name="GeneratedTests",
            target_file="main",
            framework=framework,
            test_cases=test_cases,
            imports=self._get_default_imports(language)
        )
    
    def _extract_functions(self, code: str, language: str) -> List[str]:
        """Extract function names from code."""
        functions = []
        
        if language == 'python':
            import re
            matches = re.findall(r'def\s+(\w+)\s*\(', code)
            functions = [m for m in matches if not m.startswith('_')]
        elif language == 'typescript':
            import re
            # Match function declarations and arrow functions
            matches = re.findall(r'(?:function\s+(\w+)|const\s+(\w+)\s*=\s*(?:async\s*)?\()', code)
            functions = [m[0] or m[1] for m in matches]
        elif language == 'csharp':
            import re
            matches = re.findall(r'public\s+\w+\s+(\w+)\s*\(', code)
            functions = matches
        
        return functions
    
    def _generate_basic_test(self, func_name: str, language: str) -> str:
        """Generate basic test assertion."""
        if language == 'python':
            return f'result = {func_name}()\nassert result is not None'
        elif language == 'typescript':
            return f'const result = {func_name}();\nexpect(result).toBeDefined();'
        elif language == 'csharp':
            return f'var result = {func_name}();\nAssert.NotNull(result);'
        return '# TODO: Implement test'
    
    def _generate_edge_case_test(self, func_name: str, language: str) -> str:
        """Generate edge case test."""
        if language == 'python':
            return f'# Test with edge case inputs\nwith pytest.raises(Exception):\n    {func_name}(None)'
        elif language == 'typescript':
            return f'// Test with edge case inputs\nexpect(() => {func_name}(null)).toThrow();'
        elif language == 'csharp':
            return f'// Test with edge case inputs\nAssert.Throws<ArgumentNullException>(() => {func_name}(null));'
        return '# TODO: Implement edge case test'
    
    def _get_default_imports(self, language: str) -> List[str]:
        """Get default imports for language."""
        if language == 'python':
            return ['from main import *']
        elif language == 'typescript':
            return ["import * as main from './main';"]
        elif language == 'csharp':
            return ['using TestProject;']
        return []
    
    def _build_test_generation_prompt(
        self,
        code: str,
        language: str,
        framework: TestFramework,
        context: Dict[str, Any] = None
    ) -> str:
        """Build prompt for LLM test generation."""
        return f"""Generate comprehensive unit tests for the following {language} code.

Use {framework.value} framework.

CODE:
```{language}
{code}
```

Generate tests covering:
1. Happy path scenarios
2. Edge cases (null inputs, empty collections, boundary values)
3. Error scenarios

Return ONLY the test code, no explanations.
"""
    
    async def _generate_integration_suite(
        self,
        milestone: Dict[str, Any],
        files: Dict[str, str]
    ) -> TestSuite:
        """Generate integration test suite for a milestone."""
        # Placeholder implementation
        return TestSuite(
            name=milestone.get('name', 'IntegrationTests'),
            target_file='integration',
            framework=TestFramework.PYTEST,
            test_cases=[]
        )
