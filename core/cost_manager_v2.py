"""\nEnhanced cost management with real-time tracking and multi-tier budgets.\n\nThis module provides comprehensive cost tracking and budget enforcement\nfor LLM API calls across multiple providers (OpenAI, Anthropic, Google).\n\nFeatures:\n- Multi-tier budgets (per-task, hourly, daily)\n- Real-time cost tracking per model and provider\n- Alert system at 80% threshold\n- Per-phase cost breakdown\n- Cost reports and exports\n- Historical tracking\n\nVersion: 2.0.0\n\"""\n\nfrom __future__ import annotations\n\nimport logging\nimport json\nimport time\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Tuple\nfrom dataclasses import dataclass, field, asdict\nfrom pathlib import Path\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass ModelPricing:\n    \"\"\"Pricing information for a specific model.\"\"\"\n    input_per_million: float  # USD per million input tokens\n    output_per_million: float  # USD per million output tokens\n    provider: str\n    context_window: int = 128000\n\n\n@dataclass\nclass UsageRecord:\n    \"\"\"Single usage record for cost tracking.\"\"\"\n    timestamp: float\n    model: str\n    provider: str\n    phase: str\n    tokens_input: int\n    tokens_output: int\n    tokens_total: int\n    cost_usd: float\n    task_id: Optional[str] = None\n\n\n@dataclass\nclass CostAlert:\n    \"\"\"Alert when budget threshold is reached.\"\"\"\n    timestamp: float\n    level: str  # \"warning\" or \"critical\"\n    budget_type: str  # \"task\", \"hour\", \"day\"\n    current_cost: float\n    budget_limit: float\n    percentage: float\n    message: str\n\n\n@dataclass\nclass CostReport:\n    \"\"\"Comprehensive cost report.\"\"\"\n    start_time: float\n    end_time: float\n    total_cost: float\n    total_tokens: int\n    by_model: Dict[str, Dict[str, float]]  # model -> {cost, tokens}\n    by_provider: Dict[str, Dict[str, float]]  # provider -> {cost, tokens}\n    by_phase: Dict[str, Dict[str, float]]  # phase -> {cost, tokens}\n    num_calls: int\n    alerts: List[CostAlert]\n\n\nclass CostManagerV2:\n    \"\"\"\n    Enhanced cost manager with multi-tier budgets and real-time tracking.\n    \n    Example\n    -------\n    >>> manager = CostManagerV2(\n    ...     per_task_budget=0.50,\n    ...     per_hour_budget=5.0,\n    ...     per_day_budget=40.0\n    ... )\n    >>> \n    >>> # Track usage\n    >>> manager.track_usage(\n    ...     provider=\"openai\",\n    ...     model=\"gpt-4o\",\n    ...     tokens_used={\"prompt\": 1000, \"completion\": 500, \"total\": 1500},\n    ...     phase=\"implementer\"\n    ... )\n    >>> \n    >>> # Check if can proceed\n    >>> if manager.can_proceed():\n    ...     # Make LLM call\n    ...     pass\n    >>> \n    >>> # Get report\n    >>> report = manager.generate_report()\n    >>> print(f\"Total cost: ${report.total_cost:.4f}\")\n    \"\"\"\n    \n    # Pricing table (USD per million tokens)\n    # Source: Public pricing as of Feb 2026\n    PRICING = {\n        # OpenAI\n        \"gpt-4o\": ModelPricing(2.50, 10.0, \"openai\", 128000),\n        \"gpt-4o-mini\": ModelPricing(0.15, 0.60, \"openai\", 128000),\n        \"gpt-4-turbo\": ModelPricing(10.0, 30.0, \"openai\", 128000),\n        \"gpt-3.5-turbo\": ModelPricing(0.50, 1.50, \"openai\", 16000),\n        \n        # Anthropic\n        \"claude-3-5-sonnet\": ModelPricing(3.00, 15.0, \"anthropic\", 200000),\n        \"claude-3-opus\": ModelPricing(15.0, 75.0, \"anthropic\", 200000),\n        \"claude-3-sonnet\": ModelPricing(3.00, 15.0, \"anthropic\", 200000),\n        \"claude-3-haiku\": ModelPricing(0.25, 1.25, \"anthropic\", 200000),\n        \n        # Google\n        \"gemini-2.5-pro\": ModelPricing(1.25, 5.0, \"google\", 1000000),\n        \"gemini-1.5-pro\": ModelPricing(1.25, 5.0, \"google\", 2000000),\n        \"gemini-1.5-flash\": ModelPricing(0.075, 0.30, \"google\", 1000000),\n    }\n    \n    def __init__(\n        self,\n        per_task_budget: float = 0.50,\n        per_hour_budget: float = 5.0,\n        per_day_budget: float = 40.0,\n        alert_threshold: float = 0.8,  # Alert at 80%\n        enable_history: bool = True,\n        history_dir: Optional[str] = None\n    ):\n        \"\"\"\n        Initialize cost manager.\n        \n        Parameters\n        ----------\n        per_task_budget : float\n            Maximum cost per task in USD.\n        per_hour_budget : float\n            Maximum cost per hour in USD.\n        per_day_budget : float\n            Maximum cost per day in USD.\n        alert_threshold : float\n            Alert when budget reaches this percentage (0.0-1.0).\n        enable_history : bool\n            Whether to persist usage history to disk.\n        history_dir : str, optional\n            Directory for history files (default: ./cost_history).\n        \"\"\"\n        # Budgets\n        self.per_task_budget = per_task_budget\n        self.per_hour_budget = per_hour_budget\n        self.per_day_budget = per_day_budget\n        self.alert_threshold = alert_threshold\n        \n        # Tracking\n        self.usage_records: List[UsageRecord] = []\n        self.alerts: List[CostAlert] = []\n        self.current_task_cost = 0.0\n        self.current_task_id: Optional[str] = None\n        self.current_phase: str = \"unknown\"\n        \n        # Time-based tracking\n        self.hour_start = time.time()\n        self.day_start = time.time()\n        self.hour_cost = 0.0\n        self.day_cost = 0.0\n        \n        # Alert state\n        self._task_alert_fired = False\n        self._hour_alert_fired = False\n        self._day_alert_fired = False\n        \n        # History persistence\n        self.enable_history = enable_history\n        if enable_history:\n            self.history_dir = Path(history_dir or \"./cost_history\")\n            self.history_dir.mkdir(exist_ok=True)\n    \n    def track_usage(\n        self,\n        provider: str,\n        model: str,\n        tokens_used: Dict[str, int],\n        phase: Optional[str] = None,\n        task_id: Optional[str] = None\n    ) -> float:\n        \"\"\"\n        Track token usage and calculate cost.\n        \n        Parameters\n        ----------\n        provider : str\n            Provider name (\"openai\", \"anthropic\", \"google\").\n        model : str\n            Model identifier.\n        tokens_used : dict\n            Dict with \"prompt\", \"completion\", \"total\" keys.\n        phase : str, optional\n            Current phase (analyst, architect, etc.).\n        task_id : str, optional\n            Current task identifier.\n        \n        Returns\n        -------\n        float\n            Cost of this usage in USD.\n        \"\"\"\n        # Normalize model name\n        model_key = model.lower()\n        if model_key not in self.PRICING:\n            logger.warning(f\"Unknown model {model}, using gpt-4o pricing\")\n            model_key = \"gpt-4o\"\n        \n        pricing = self.PRICING[model_key]\n        \n        # Calculate cost\n        input_tokens = tokens_used.get(\"prompt\", 0)\n        output_tokens = tokens_used.get(\"completion\", 0)\n        total_tokens = tokens_used.get(\"total\", input_tokens + output_tokens)\n        \n        cost = (\n            (input_tokens / 1_000_000) * pricing.input_per_million +\n            (output_tokens / 1_000_000) * pricing.output_per_million\n        )\n        \n        # Create usage record\n        record = UsageRecord(\n            timestamp=time.time(),\n            model=model,\n            provider=provider,\n            phase=phase or self.current_phase,\n            tokens_input=input_tokens,\n            tokens_output=output_tokens,\n            tokens_total=total_tokens,\n            cost_usd=cost,\n            task_id=task_id or self.current_task_id\n        )\n        \n        self.usage_records.append(record)\n        \n        # Update running totals\n        self.current_task_cost += cost\n        self._update_time_based_costs(cost)\n        \n        # Check budgets and emit alerts\n        self._check_budgets()\n        \n        # Persist if enabled\n        if self.enable_history:\n            self._append_to_history(record)\n        \n        logger.info(\n            f\"Usage tracked: {model} ({provider}), {total_tokens} tokens, \"\n            f\"${cost:.4f} (task: ${self.current_task_cost:.4f})\"\n        )\n        \n        return cost\n    \n    def can_proceed(self) -> bool:\n        \"\"\"\n        Check if execution can proceed within budget constraints.\n        \n        Returns\n        -------\n        bool\n            True if all budgets allow continuation.\n        \"\"\"\n        if self.current_task_cost >= self.per_task_budget:\n            logger.error(\"Per-task budget exceeded\")\n            return False\n        \n        if self.hour_cost >= self.per_hour_budget:\n            logger.error(\"Hourly budget exceeded\")\n            return False\n        \n        if self.day_cost >= self.per_day_budget:\n            logger.error(\"Daily budget exceeded\")\n            return False\n        \n        return True\n    \n    def start_task(self, task_id: str, phase: str = \"unknown\"):\n        \"\"\"Start tracking a new task.\"\"\"\n        self.current_task_id = task_id\n        self.current_phase = phase\n        self.current_task_cost = 0.0\n        self._task_alert_fired = False\n        logger.info(f\"Started tracking task: {task_id} (phase: {phase})\")\n    \n    def end_task(self) -> float:\n        \"\"\"End current task and return its cost.\"\"\"\n        cost = self.current_task_cost\n        logger.info(f\"Task {self.current_task_id} completed. Cost: ${cost:.4f}\")\n        self.current_task_id = None\n        self.current_task_cost = 0.0\n        return cost\n    \n    def get_cumulative_cost(self) -> float:\n        \"\"\"Get cumulative cost across all usage.\"\"\"\n        return sum(r.cost_usd for r in self.usage_records)\n    \n    def generate_report(\n        self,\n        since: Optional[float] = None\n    ) -> CostReport:\n        \"\"\"\n        Generate comprehensive cost report.\n        \n        Parameters\n        ----------\n        since : float, optional\n            Unix timestamp to start report from.\n        \n        Returns\n        -------\n        CostReport\n            Detailed breakdown of costs.\n        \"\"\"\n        # Filter records\n        records = self.usage_records\n        if since:\n            records = [r for r in records if r.timestamp >= since]\n        \n        if not records:\n            return CostReport(\n                start_time=time.time(),\n                end_time=time.time(),\n                total_cost=0.0,\n                total_tokens=0,\n                by_model={},\n                by_provider={},\n                by_phase={},\n                num_calls=0,\n                alerts=self.alerts\n            )\n        \n        # Aggregate by model\n        by_model = defaultdict(lambda: {\"cost\": 0.0, \"tokens\": 0})\n        for r in records:\n            by_model[r.model][\"cost\"] += r.cost_usd\n            by_model[r.model][\"tokens\"] += r.tokens_total\n        \n        # Aggregate by provider\n        by_provider = defaultdict(lambda: {\"cost\": 0.0, \"tokens\": 0})\n        for r in records:\n            by_provider[r.provider][\"cost\"] += r.cost_usd\n            by_provider[r.provider][\"tokens\"] += r.tokens_total\n        \n        # Aggregate by phase\n        by_phase = defaultdict(lambda: {\"cost\": 0.0, \"tokens\": 0})\n        for r in records:\n            by_phase[r.phase][\"cost\"] += r.cost_usd\n            by_phase[r.phase][\"tokens\"] += r.tokens_total\n        \n        total_cost = sum(r.cost_usd for r in records)\n        total_tokens = sum(r.tokens_total for r in records)\n        \n        return CostReport(\n            start_time=records[0].timestamp,\n            end_time=records[-1].timestamp,\n            total_cost=total_cost,\n            total_tokens=total_tokens,\n            by_model=dict(by_model),\n            by_provider=dict(by_provider),\n            by_phase=dict(by_phase),\n            num_calls=len(records),\n            alerts=self.alerts\n        )\n    \n    def export_report(\n        self,\n        output_path: str,\n        format: str = \"json\"\n    ):\n        \"\"\"Export cost report to file.\"\"\"\n        report = self.generate_report()\n        \n        with open(output_path, \"w\") as f:\n            if format == \"json\":\n                json.dump(asdict(report), f, indent=2)\n            else:\n                raise ValueError(f\"Unsupported format: {format}\")\n        \n        logger.info(f\"Cost report exported to {output_path}\")\n    \n    def _update_time_based_costs(self, cost: float):\n        \"\"\"Update hourly and daily cost trackers.\"\"\"\n        now = time.time()\n        \n        # Check if hour has rolled over\n        if now - self.hour_start >= 3600:\n            logger.info(f\"Hour completed. Cost: ${self.hour_cost:.4f}\")\n            self.hour_start = now\n            self.hour_cost = 0.0\n            self._hour_alert_fired = False\n        \n        # Check if day has rolled over\n        if now - self.day_start >= 86400:\n            logger.info(f\"Day completed. Cost: ${self.day_cost:.4f}\")\n            self.day_start = now\n            self.day_cost = 0.0\n            self._day_alert_fired = False\n        \n        self.hour_cost += cost\n        self.day_cost += cost\n    \n    def _check_budgets(self):\n        \"\"\"Check budgets and emit alerts if thresholds reached.\"\"\"\n        # Task budget\n        task_pct = self.current_task_cost / self.per_task_budget\n        if not self._task_alert_fired and task_pct >= self.alert_threshold:\n            self._emit_alert(\n                level=\"warning\",\n                budget_type=\"task\",\n                current=self.current_task_cost,\n                limit=self.per_task_budget,\n                percentage=task_pct\n            )\n            self._task_alert_fired = True\n        \n        # Hour budget\n        hour_pct = self.hour_cost / self.per_hour_budget\n        if not self._hour_alert_fired and hour_pct >= self.alert_threshold:\n            self._emit_alert(\n                level=\"warning\",\n                budget_type=\"hour\",\n                current=self.hour_cost,\n                limit=self.per_hour_budget,\n                percentage=hour_pct\n            )\n            self._hour_alert_fired = True\n        \n        # Day budget\n        day_pct = self.day_cost / self.per_day_budget\n        if not self._day_alert_fired and day_pct >= self.alert_threshold:\n            self._emit_alert(\n                level=\"warning\",\n                budget_type=\"day\",\n                current=self.day_cost,\n                limit=self.per_day_budget,\n                percentage=day_pct\n            )\n            self._day_alert_fired = True\n    \n    def _emit_alert(\n        self,\n        level: str,\n        budget_type: str,\n        current: float,\n        limit: float,\n        percentage: float\n    ):\n        \"\"\"Emit cost alert.\"\"\"\n        alert = CostAlert(\n            timestamp=time.time(),\n            level=level,\n            budget_type=budget_type,\n            current_cost=current,\n            budget_limit=limit,\n            percentage=percentage,\n            message=f\"{level.upper()}: {budget_type} budget at {percentage:.0%} \"\n                    f\"(${current:.4f} / ${limit:.2f})\"\n        )\n        \n        self.alerts.append(alert)\n        logger.warning(alert.message)\n    \n    def _append_to_history(self, record: UsageRecord):\n        \"\"\"Append usage record to history file.\"\"\"\n        # Create daily history file\n        date_str = datetime.fromtimestamp(record.timestamp).strftime(\"%Y-%m-%d\")\n        history_file = self.history_dir / f\"usage_{date_str}.jsonl\"\n        \n        with open(history_file, \"a\") as f:\n            f.write(json.dumps(asdict(record)) + \"\\n\")\n