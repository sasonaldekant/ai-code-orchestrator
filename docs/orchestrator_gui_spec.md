# AI Code Orchestrator v3.0 - GUI Design Specification

## "Nexus" - The Premium Local-First AI Orchestrator Interface

### 1. Executive Summary

"Nexus" is the proposed graphical user interface for the AI Code Orchestrator v3.0. Unlike generic chat interfaces, Nexus is designed as a **Command Center** for AI software development. It leverages our unique control over the entire stack (database, schemas, RAG, components) to provide deep, context-aware features that generic tools cannot match.

**Philosophy:**

- **Local & Lightweight:** Runs entirely on the user's machine (CPU-optimized, Electron/React-based) without needing heavy local LLMs.
- **Transparent Reasoning:** Demystifies the "black box" by visualizing the AI's thought process, RAG retrievals, and architectural decisions in real-time.
- **Deep Integration:** Tightly coupled with the local file system and project structure.

---

### 2. Technology Stack

We will use a modern, performance-oriented stack that ensures a premium look and feel (60fps animations, instant interactions) with minimal resource footprint.

- **Frontend**:
  - **Framework**: **React 18+** with **Vite** (for blazing fast dev/build).
  - **Language**: **TypeScript**.
  - **Styling**: **Tailwind CSS** + **Framer Motion** (for smooth, "Apple-like" animations).
  - **UI Library**: **Shadcn/UI** (Radix Primitives) for accessible, high-quality component design (Dialogs, Popovers, Tabs).
  - **State Management**: **Zustand** (lightweight alternative to Redux).

- **Backend Integration**:
  - **Server**: **FastAPI** (Existing `api/app.py` extended).
  - **Protocol**: **Server-Sent Events (SSE)** for one-way streaming of reasoning logs/tokens, and **REST** for CRUD operations.
  - **File System**: Direct access allows the UI to open/edit local files.

---

### 3. Core Functional Modules

#### A. The "Thought Stream" (Better than Perplexity)

Standard chat UIs hide the logic. Nexus treats the reasoning calculation as a first-class citizen.

- **Collapsible Thinking Blocks:** Every user request spawns a "Thinking" block.
- **Live Step Visualization:** As the `LifecycleOrchestrator` runs, steps appear in real-time:
  - _Examples:_ `[Retrieving Context...]`, `[Analyzing Schema: Order.cs]`, `[Planning: 4 Milestones]`.
- **Deep Linking:** When the log says "Checked Order.cs", the filename is clickable. Clicking it opens a split-view seeing that file.
- **RAG Citations:** When the AI makes a claim about the domain, it cites the retrieval source. hovering over the citation shows the exact chunk of code/doc retrieved from the vector store.

#### B. The "Orchestration Plan" Board

A dedicated panel visualizing the `ImplementationPlan`.

- **Dynamic Checklist:** The JSON plan generated by the `ArchitectAgent` is rendered as an interactive task list.
- **State Indicators:** Tasks turn from "Pending" (Grey) to "In Progress" (Pulsing Blue) to "Completed" (Green) or "Review Needed" (Yellow) in real-time.
- **Manual Intervention:** The user can pause execution, edit a future task description, and resume—something impossible in standard chat flows.

#### C. Live Artifact Workshop

A tabbed code editor view (using `Monaco Editor` component—the engine that powers VS Code).

- **Live Gen:** Watch code being written character-by-character.
- **Diff View:** For "Refactor" tasks, show a side-by-side Diff of Before vs After.
- **One-Click Apply:** Button to confirm writing the file to disk.

#### D. Knowledge Graph Explorer (Unique Feature)

Since we ingested the database and components, we can visualize them.

- **Interactive Graph:** A node-link diagram showing how Entities relate (e.g., `User` -> `Orders`).
- **Component Tree:** Visual hierarchy of React components.
- **Usage:** User can drag a node (e.g., "ProductCard") into the chat input to explicitly tell the AI "Use this component".

#### E. Cost & Performance HUD

- **Token Ticker:** An odometer-style counter showing session cost in real-time ($0.04... $0.05...).
- **Model Routing Display:** Shows which model is currently active (e.g., "Switching to Claude 3.5 for Architecture...").

---

### 4. Integration Strategy

#### Backend Extensions (`api/app.py`)

We need to add new endpoints to support this transparency:

1.  **`GET /stream/logs`**: An SSE endpoint. The `Orchestrator` needs to push events to a specialized `EventBus`. The API subscribes to this bus and yields events to the UI.
2.  **`GET /context/graph`**: Returns the nodes and edges of the ingested domain knowledge for the visualizer.
3.  **`POST /plan/edit`**: Allows the frontend to modify the executing plan on the fly.

#### The "Event Bus" Architecture

Instead of just logging to a file, the `Logger` will pump structure events:

```json
{
  "type": "thought",
  "agent": "Architect",
  "message": "Analyzing dependency graph...",
  "timestamp": 123456789
}
```

The Frontend renders these distinct event types differently (Code vs Text vs Error).

---

#### F. File Output Panel (NEW)

Dedicated panel for reviewing and approving file changes.

- **Pending Files List:** Queue of files waiting for approval.
- **Diff View:** Side-by-side or unified diff of changes.
- **Approve/Reject Buttons:** Per-file or batch approval.
- **Backup Indicator:** Shows if backup exists for rollback.

**Implementation Notes:**

- Uses `FileWriter.preview()` for diff generation.
- Shows file path, additions/deletions count.
- Integrates with Git status if available.

#### G. Code Verification Panel (NEW)

Real-time display of code verification status.

- **Test Status:** Pass/Fail indicators for each test.
- **Execution Time:** How long tests took.
- **Retry Counter:** Shows retry attempts (max 3).
- **Error Details:** Expandable error messages on failure.

**Event Types:**

```json
{
  "type": "verification",
  "phase": "testing",
  "status": "running|passed|failed",
  "tests_passed": 5,
  "tests_failed": 1,
  "execution_time_ms": 1250
}
```

---

### 5. Implementation Roadmap

1.  **Phase 1: Foundation**
    - Setup `ui/` React project.
    - Implement `EventBus` in Python backend.
    - Basic Chat + Log Streaming.

2.  **Phase 2: Visualization**
    - Plan Board (Task list).
    - Markdown & Code rendering in chat.
    - Thinking collapsibles.

3.  **Phase 3: Deep Integration**
    - Knowledge Graph.
    - File System browsing.
    - Diff Viewer.

4.  **Phase 4: Quality Gates (NEW)**
    - Code Verification Panel.
    - File Output Panel with diff view.
    - Approval workflow for file writes.

---

### 6. Why This is "Better"

- **Control:** We don't just "talk" to the AI; we allow the user to **manipulate the plan** while it's running.
- **Context:** Generic tools guess the context. Nexus **visualizes** the context (Schema/Component Library) so the user knows exactly what the AI knows.
- **Privacy:** Complete data isolation. No code leaves the local network except to the LLM provider API (which is stateless).
- **Quality:** Every piece of code is **verified** before it touches your project.
- **Safety:** Full **backup and rollback** system protects against bad changes.
